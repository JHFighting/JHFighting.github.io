<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Python学习记录 -- 知识碎片]]></title>
      <url>%2F2016%2F11%2F18%2Fpython-piece%2F</url>
      <content type="text"><![CDATA[python一问一答 1、为什么dict查找速度这么快?因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。dict就是第二种实现方式，给定一个名字，比如Michael，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。 2、函数可以返回多个值吗？12345import mathdef move(x,y,step,angle=0): nx = x + step*math.cos(angle) ny = y - step*math.sin(angle) return nx,ny 然后，我们就可以同时获得返回值： 123&gt;&gt;&gt;x,y=move(100,100,60,math.pi/6)&gt;&gt;&gt;print(x,y)151.9615242270663270.0 但其实这只是一种假象，Python函数返回的仍然是单一值： 123&gt;&gt;&gt;r=move(100,100,60,math.pi/6)&gt;&gt;&gt;print(r)(151.96152422706632,70.0) 原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 3、函数定义默认参数为什么一定要指向不变对象？先定义一个函数，传入一个list，添加一个END再返回： 123def add_end(L = []): L.append('END') return L 当你正常调用时，结果似乎不错： 1234&gt;&gt;&gt;add_end([1,2,3])[1,2,3,'END']&gt;&gt;&gt;add_end(['x','y','z'])['x','y','z','END'] 当你使用默认参数调用时，一开始结果也是对的： 123&gt;&gt;&gt;add_end()['END'] 但是，再次调用add_end()时，结果就不对了： 1234&gt;&gt;&gt;add_end()['END','END']&gt;&gt;&gt;add_end()['END','END','END'] 很多初学者很疑惑，默认参数是[]，但是函数似乎每次都“记住了”上次添加了’END’后的list。原因解释如下：Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。所以，定义默认参数要牢记一点：默认参数必须指向不变对象！要修改上面的例子，我们可以用None这个不变对象来实现： 12345def add_end(L=None): if LisNone: L=[] L.append('END') return L 现在，无论调用多少次，都不会有问题： 1234&gt;&gt;&gt;add_end()['END']&gt;&gt;&gt;add_end()['END'] 为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。 4、python有私有变量吗？Python 用下划线作为变量前缀和后缀指定特殊变量。_xxx: 不能用from module import *导入__xxx__ : 系统定义名字__xxx : 类中的私有变量名 因为下划线对解释器有特殊的意义，而且是内建标识符所使用的符号，我们建议程序员避免用下划线作为变量名的开始。一般来讲，变量名_xxx被看作是”私有的”，在模块或类外不可以使用。当变量是私有的时候，用_xxx来表示变量是很好的习惯。“单下划线” 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量；“双下划线” 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。例： 123456class Student(object): def__init__(self,name,score): self.__name=name self.__score=score def print_score(self): print('%s:%s'%(self.__name,self.__score)) 无法从外部访问实例变量.__name和实例变量.__score 12345&gt;&gt;&gt;bart=Student('BartSimpson',98)&gt;&gt;&gt;bart.__nameTraceback(mostrecentcalllast):File"&lt;stdin&gt;",line1,in&lt;module&gt;AttributeError:'Student'objecthasnoattribute'__name' 不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量： 12&gt;&gt;&gt;bart._Student__name'BartSimpson' 所以Python没有真正的私有变量。内部实现上，是将私有变量进程了转化，规则是：_&lt;类名&gt;&lt;私有变量&gt;但我们还是要按照约定俗成的规定，避免一些不必要的冲突和错误。 5、is和==这两种运算符相同吗？首先要知道Python中对象包含的三个基本要素，分别是：id(身份标识)、python type()(数据类型)和value(值)。例子1： 1234567891011&gt;&gt;&gt;a=[1,2,3]&gt;&gt;&gt;b=a&gt;&gt;&gt;b is a #a的引用复制给b，他们在内存中其实是指向了用一个对象True&gt;&gt;&gt;b==a #当然，他们的值也是相等的True&gt;&gt;&gt;b=a[:] #b通过a切片获得a的部分，这里的切片操作重新分配了对象&gt;&gt;&gt;b is a #所以指向的不是同一个对象了False&gt;&gt;&gt;b==a #但他们的值还是相等的True is比较的是两者是否是同一个对象，所以比较的是内存地址（id是否相同）。==是值比较。不可变对象，例如int，str，它会直接进行值比较。对于Python已知的对象，会调用他们的__eq__函数来比较。（其实已知的对象应该也是通过内置的__eq__函数来比较的）。对于自定义的对象，如果实现了__eq__函数，就会使用它比较，如果没有实现，效果和==是一样的。Python会对比较小的对象缓存，下次用到比较小的对象时，会去缓存区查找，如果找到，不会再开辟新的内存，而是继续把小对象的地址赋给新的值。例子2： 12345678&gt;&gt;&gt;c=1&gt;&gt;&gt;d=1&gt;&gt;&gt;print(c is d)True&gt;&gt;&gt;1000 is 10**3False&gt;&gt;&gt;1000 == 10**3True 通过计算得到的赋值，不会使用缓存区。待续~~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx+keepalived主备]]></title>
      <url>%2F2016%2F11%2F18%2Fnginx-keepalived%2F</url>
      <content type="text"><![CDATA[本文主要讲述在linux系统下，利用keepalived做主备服务器自动切换（主服务器宕掉，备份服务器自动成为主服务器），配合nginx搭建服务界面。 一、介绍1.Keepalived介绍 Keepalived是一个基于VRRP协议来实现的服务高可用方案，保持存活，在网络里面就是保持在线，也就是所谓的高可用或热备。可以利用其来避免IP单点故障，类似的工具还有heartbeat、corosync、pacemaker。但是它一般不会单独出现，而是与其它负载均衡技术（如lvs、haproxy、nginx）一起工作来达到集群的高可用。 VRRP协议—虚拟路由冗余协议。可以认为它是实现路由器高可用的容错协议，即将N台提供相同功能的路由器组成一个路由器组(RouterGroup)，这个组里面有一个master和多个backup，但在外界看来就像一台一样，构成虚拟路由器，拥有一个虚拟IP（vip，也就是路由器所在局域网内其他机器的默认路由），占有这个IP的master实际负责ARP相应和转发IP数据包，组中的其它路由器作为备份的角色处于待命状态。master会发组播消息，当backup在超时时间内收不到vrrp包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master，保证路由器的高可用。 2.Keepalived组件 keepalived的组件：core： 是keepalived的核心，负责主进程的启动和维护，全局配置文件的加载解析等。check：负责health checker（健康检查），包括了各种健康检查方式，以及对应的配置的解析，包括LVS的配置解析。vrrp：VRRPD子进程，VRRPD子进程就是来实现VRRP协议的。 3.nginx介绍 Nginx是一款轻量级的网页服务器、反向代理服务器以及电子邮件代理服务器，特点是占有内存少、并发能力强。Nginx自身的负载均衡功能，可以通过定义Upstream地址池，通过相应的分法原则实现网站访问的首选利器。 二、安装配置1 Keepalived1.1 keepalived安装 下载keepalived http://www.keepalived.org/software/keepalived-1.2.12.tar.gz将其上传到/usr/local/src目录下。 (或使用yum安装： yum install –y keepalived) cd /usr/local/src tar zxvf keepalived-1.2.12.tar.gz cd keepalived-1.2.12 ./configure –prefix=/usr/local/keepalived (安装到/usr/local/keepalived目录下) 配置必须看到以下提示，说明配置正确，才能继续安装：Use IPVS Framework : YesIPVS sync daemon support : Yes Use VRRP Framework : Yes make // 编辑 make install // 安装 cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/keepalived(复制到配置里的默认路径下/etc/sysconfig/keepalived) mkdir /etc/keepalived ln –s /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/ (将配置文件keepalived.conf链接到/etc/keepalived目录下) cp /usr/local/keepalived/sbin/keepalived /usr/sbin/ cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/rc.d/init.d/(复制到默认的执行路径下/etc/rc.d/init.d/，这是建立服务启动脚本，以便用service命令控制) chmod +x /etc/rc.d/init.d/keepalived (添加执行权限) chkconfig keepalived on (设置开机启动) 1.2 配置keepalived.conf#vim /etc/keepalived/keepalived.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657! Configuration File for keepalived global_defs &#123; // 通知的邮箱 notification_email &#123; youxiang@example.com &#125; notification_email_from itsection@example.com // 发送email时使用的smtp服务器地址 smtp_server mail.example.com // 连接smtp超时时间 smtp_connect_timeout 30 // 机器标识 router_id LVS_DEVEL &#125; // 告诉keepalived在什么情况下切换vrrp_script chk_nginx &#123; # script "killall -0 nginx" // 自己写的检测脚本，这里是一个监听Nginx的脚本 script "/etc/keepalived/check_nginx.sh" // 每2s检测一次 interval 2 // 检测失败(脚本返回非0)，则优先级-5 weight -5 // 检测连续2次算是真失败 fall 2 // 检测1次成功就算成功 rise 1 &#125; vrrp_instance VI_1 &#123; // 服务器状态：master(主服务器) backup(备份服务器) state MASTER // 绑定的网卡 interface eth0 // 服务器IP mcast_src_ip 10.4.248.10 // 设置VRID，相同的VRID为一个组，它将决定多播的MAC地址 virtual_router_id 51 // 优先级(数字越大，优先级越高，优先级高的为master) priority 101 // 检查间隔 advert_int 2 // 定义认证方式和密码，主从必须一样 authentication &#123; auth_type PASS auth_pass 1111 &#125; // 虚拟IP virtual_ipaddress &#123; 219.237.93.162 &#125; // 引用VRRP脚本，定期运行来改变优先级 track_script &#123; chk_nginx &#125; &#125; 在其他备机BACKUP上，只需要改变state MASTER → state BACKUP，priority 101 → priority 100，mcast_src_ip 10.4.248.10 → mcast_src_ip 10.4.248.11 即可。 1.3 keepalived命令 service keepalived start #启动service keepalived stop #关闭service keepalived restart #重启 2 Nginx2.1 nginx安装 首先使用yum安装缺少的依赖包： yum -y install gcc gcc-c++ make libtool zlib zlib-devel openssl openssl-devel pcre pcre-devel cd /usr/local/src 从 http://www.nginx.org/download 中下载nginx (以nginx-1.6.1为例) tar zxvf nginx-1.6.1.tar.gz cd nginx-1.6.1 mkdir /usr/local/nginx ./configure –prefix=/usr/local/nginx/ (将nginx安装到/usr/local/nginx目录下) make &amp;&amp; make install 2.2 nginx命令 /usr/local/nginx/sbin/nginx #启动/usr/local/nginx/sbin/nginx –s stop #关闭 3 nginx监控脚本该脚本检测nginx的运行状态，并在nginx进程不存在时尝试重新启动nginx。若重新启动失败，则将keepalived关闭，已达到切换服务器的功能。 #vim /etc/keepalived/check_nginx.sh以下为脚本内容： 1234567891011121314 #!/bin/bash// 监控nginx进程状态counter=$(ps -C nginx --no-heading|wc -l) // 如果nginx进程不存在if [ "$&#123;counter&#125;" = "0" ]; then // 尝试重启nginx /usr/local/nginx/sbin/nginx sleep 2 counter=$(ps -C nginx --no-heading|wc -l) if [ "$&#123;counter&#125;" = "0" ]; then // 停止keepalived服务 /etc/rc.d/init.d/keepalived stop fifi]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ajax学习总结]]></title>
      <url>%2F2016%2F11%2F18%2Fajax%2F</url>
      <content type="text"><![CDATA[主要内容包括Ajax的概念、基本使用方法以及jQuery中ajax的使用。 一、概念AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。AJAX 不是新的编程语言，而是一种使用现有标准的新方法。AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。 二、ajax请求1. 创建ajax对象XMLHttpRequest对象用于和服务器交换数据。在创建对象时，有兼容问题: 12var oAjax = new XMLHttpRequest(); // for ie6 以上var oAjax = new ActiveXObject('Microsoft.XMLHTTP'); // for ie6 合并代码： 123456var oAjax = null;if (window.XMLHttpRequest) &#123; oAjax = new XMLHttpRequest();&#125; else &#123; oAjax = new ActiveXObject('Microsoft.XMLHTTP');&#125; 2. 连接服务器在这里会用到open()方法。open(method, url, async)方法有三个参数: 第一个参数method是连接方法即 GET 和 POST 第二个参数url是 URL 即所要读取数据的地址 第三个参数async是否异步，它是个布尔值，true 为异步，false 为同步。 1oAjax.open('GET', url, true); 3. 发送请求send()方法。send(string)将请求发送到服务器。string：仅用于 POST 请求，用来传递请求参数 1oAjax.send(); 如果需要像 HTML 表单那样 POST 数据，请使用setRequestHeader()来添加 HTTP 头。然后在send()方法中规定您希望发送的数据：setRequestHeader(header,value)向请求添加请求头:header: 规定头的名称value: 规定头的值 123oAjax.open("POST","ajax_test.asp",true);oAjax.setRequestHeader("Content-type","application/x-www-form-urlencoded");oAjax.send("fname=Bill&amp;lname=Gates"); 4. 接收返回值onreadystatechange事件。当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当readyState改变时，就会触发onreadystatechange事件。readyState：请求状态，返回的是整数（0-4）。 0（未初始化）：还没有调用open()方法。 1（载入）：已调用send()方法，正在发送请求。 2（载入完成）：send()方法完成，已收到全部响应内容。 3（解析）：正在解析响应内容。 4（完成）：响应内容解析完成，可以在客户端调用。 status：请求结果，返回 200 或者 404。 200 =&gt; 成功。404 =&gt; 失败，未找到页面。 当readyState等于 4 且状态为 200 时，表示响应已就绪。 statusText: HTTP状态的说明。 responseText：返回内容，即我们所需要读取的数据。需要注意的是：responseText返回的是字符串。 responseXML: 获得 XML 形式的响应数据。 1234567891011oAjax.onreadystatechange=function()&#123; if(oAjax.readyState==4)&#123; if(oAjax.status==200)&#123; fnSucc(oAjax.responseText); &#125;else&#123; if(fnFaild)&#123; fnFaild(); &#125; &#125; &#125;&#125;; 5. 取消请求在接收响应之前，可以取消异步请求，abort() 1oAjax.abort(); 6. 简单Demo12345678910111213141516171819202122232425var postData = &#123; "name1": "value1", "name2": "value2"&#125;;postData = (function(obj)&#123; // 转成post需要的字符串. var str = ""; for(var prop in obj)&#123; str += prop + "=" + obj[prop] + "&amp;" &#125; return str;&#125;)(postData);var xhr = new XMLHttpRequest();xhr.open("POST", "../module", true);xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");xhr.onreadystatechange = function()&#123; var XMLHttpReq = xhr; if (XMLHttpReq.readyState == 4) &#123; if (XMLHttpReq.status == 200) &#123; var text = XMLHttpReq.responseText; console.log(text); &#125; &#125;&#125;;xhr.send(postData);// 如果需要取消请求xhr.abort(); 三、利用jQuery发送ajax请求1. 概述jQuery中的ajax()方法通过 HTTP 请求加载远程数据，该方法是 jQuery 底层 用AJAX 实现。语法： 1$.ajax(&#123;name:value, name:value, ... &#125;) 2. 配置项该参数规定 AJAX 请求的一个或多个名称/值对。下面的表格中列出了可能的名称/值： 名称 值/描述 async 布尔值，表示请求是否异步处理。默认是 true。 beforeSend(xhr) 发送请求前运行的函数。 cache 布尔值，表示浏览器是否缓存被请求页面。默认是 true。 complete(xhr,status) 请求完成时运行的函数（在请求成功或失败之后均调用，即在 success 和 error 函数之后）。 contentType 发送数据到服务器时所使用的内容类型。默认是：”application/x-www-form-urlencoded”。 context 为所有 AJAX 相关的回调函数规定 “this” 值。 data 规定要发送到服务器的数据。 dataFilter(data,type) 用于处理 XMLHttpRequest 原始响应数据的函数。 dataType 预期的服务器响应的数据类型。 error(xhr,status,error) 如果请求失败要运行的函数。 global 布尔值，规定是否为请求触发全局 AJAX 事件处理程序。默认是 true。 ifModified 布尔值，规定是否仅在最后一次请求以来响应发生改变时才请求成功。默认是 false。 jsonp 在一个 jsonp 中重写回调函数的字符串。 jsonpCallback 在一个 jsonp 中规定回调函数的名称。 password 规定在 HTTP 访问认证请求中使用的密码。 processData 布尔值，规定通过请求发送的数据是否转换为查询字符串。默认是 true。 scriptCharset 规定请求的字符集。 success(result,status,xhr) 当请求成功时运行的函数。 timeout 设置本地的请求超时时间（以毫秒计）。 traditional 布尔值，规定是否使用参数序列化的传统样式。 type 规定请求的类型（GET 或 POST）。 url 规定发送请求的 URL。默认是当前页面。 username 规定在 HTTP 访问认证请求中使用的用户名。 xhr 用于创建 XMLHttpRequest 对象的函数。 常用配置项： type：规定请求的类型（GET 或 POST）。url：规定发送请求的 URL。dataType ：服务器响应的数据类型，可用值： 1234561. &quot;xml&quot;: 返回 XML 文档，可用 jQuery 处理。 2. &quot;html&quot;: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。 3. &quot;script&quot;: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 &quot;cache&quot; 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载）4. &quot;json&quot;: 返回 JSON 数据 。5. &quot;jsonp&quot;: JSONP 格式。使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。6. &quot;text&quot;: 返回纯文本字符串 data：发送到服务器的数据，发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[“bar1”, “bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。success​：请求成功回调函数。error：请求失败回调函。 3. 简单Demo1234567$.ajax(&#123; type:"GET", url:"/network/jsondata/?datestyle="+dateStyle, dataType:"json", success:eval("callback"), error:function()&#123;alert("error")&#125; &#125;); 未完待续~~~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac上使用Wireshark抓iOS设备上的包]]></title>
      <url>%2F2016%2F11%2F18%2Fmac-zhuabao%2F</url>
      <content type="text"><![CDATA[在mac系统下，使用Wireshark工具来抓取iOS设备上的数据包。 1.安装Wireshark安装Wireshark前需要安装XQuartz，将XQuartz作为X11 Server。 2.准备设备 使用USB数据线将iOS设备连接到MAC上 获得iOS设备的UDID，可以使用iTools查看，也可以使用Xcode的Organizer工具查看 创建RVI接口使用如下命令行 1$ rvictl -s &lt;UDID&gt; 如图，为rvi0接口，则抓包时需要抓rvi0接口的包。 3.选择网卡，开始抓包实际上，很多情况下会出现无法发现网卡的权限问题。这就需要先给与相应的权限。首先执行 1ls -l /dev/bpf* 查看权限，若不是读写的话则需要增加权限。可以使用 1sudo chmod g+rw /dev/bpf* （重启不需要重新配置）或 1sudo chmod 644 /dev/bpf* (重启需要重新配置)。 有了权限，接下来就可以到Wireshark里抓rvi0的包，即连接的iOS设备上的包。OK！到这里就大功告成，可以开始抓包了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[视频直播第三弹 — 搭建直播服务器]]></title>
      <url>%2F2016%2F11%2F18%2FiOS-zhibo3%2F</url>
      <content type="text"><![CDATA[在Mac系统上，通过Nginx+rtmp搭建直播服务器。 简介nginx是非常优秀的开源服务器，用它来做hls或者rtmp流媒体服务器是非常不错的选择，本人在网上整理了安装流程，分享给大家并且作备忘。 步骤安装1、安装HomebrowHomebrew简称brew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，可以说Homebrew就是mac下的apt-get、yum神器 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 如果已经安装过，而想要卸载： 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)" 2、安装Nginx服务器增加对 nginx 的扩展;也就是从github上下载,home-brew对ngixnx的扩展 1brew tap homebrew/nginx 3、安装Nginx服务器和rtmp模块 1brew install nginx-full --with-rtmp-module 这个安装，耗时相对来说比较长。通过操作以上步骤nginx和rtmp模块就安装好了，下面开始来配置nginx的rtmp模块。首先来看看我们的nginx安装在哪里 1brew info nginx-full 执行上面的命令后我们可以看到信息 nginx安装所在位置 /usr/local/Cellar/nginx-full/1.10.1/bin/nginx nginx配置文件所在位置 /usr/local/etc/nginx/nginx.conf nginx服务器根目录所在位置 /usr/local/var/www 执行命令 ，测试下是否能成功启动nginx服务nginx在浏览器地址栏输入：http://localhost:8080出现Welcome to nginx ,代表nginx安装成功了。 4、配置rtmp用Xcode打开nginx.conf, 找到/usr/local/etc/nginx/nginx.conf 文件,拖入到Dock中的Xcode,就可以打开.或者打开Finder Shift + command + G前往，用记事本工具打开nginx.conf. 12345678910111213http &#123;……&#125;#在http节点下面(也就是文件的尾部)加上rtmp配置：rtmp &#123;server &#123;listen 1935;application zbcs &#123;live on;record off;&#125;&#125;&#125; 说明： rtmp是协议名称server 说明内部中是服务器相关配置listen 监听的端口号, rtmp协议的默认端口号是1935application 访问的应用路径是 zbcslive on; 开启实时record off; 不记录数据 5、 保存文件后，重新加载nginx的配置文件（这一步很重要）nginx -s reload6、 安装ffmepg工具brew install ffmpeg安装这个需要等一段时间, 这时你可以准备一个视频文件作为来推流，然后安装一个支持rtmp协议的视频播放器.Mac下可以用 VLC(点击下载)7、通过ffmepg命令进行推流 12ffmpeg -re -i 你的视频文件的绝对路径(如/Users/lideshan/Downloads/Demo.mp4) -vcodec copy -f flv rtmp://localhost:1935/zbcs/room// 如：ffmpeg -re -i /Users/jiangys/Documents/Document/demo.mp4 -vcodec copy -f flv rtmp://localhost:1935/zbcs/room 这里zbcs是上面的配置文件中,配置的应用的路径名称;后面的room可以随便写。推流界面：8、 验证视频然后电脑上打开vlc这个播放器软件 点击File—-&gt;Open Network 在弹出来的框中选择Network然后输入URL:rtmp://localhost:1935/zbcs/room双击播放播放界面 #####报错处理1、ffmepg命令推流的时候，提示连接失败。1[tcp @ 0x7ff162504b60] Connection to tcp://localhost:1935 failed (Connection refused), trying next address 出现这个错，是因为配置了nginx.conf后，需要重启nginx。输入命令重启后就没有问题了nginx -s reload2、安装完nginx后，在浏览器地址栏输入：http://localhost:8080 显示打不开网页解决方式：由于安装后nginx服务器，有时需要等上几分钟才生效。如果还不生效，测试下是否能成功启动nginx服务，命令nginx,具体请参考“步骤安装”第三点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[视频直播第二弹 — 直播框架]]></title>
      <url>%2F2016%2F11%2F18%2FiOS-zhibo2%2F</url>
      <content type="text"><![CDATA[本篇主要介绍常见的一些直播框架，并单独介绍直播框架ijkplayer。 一、常见框架 优酷土豆旗下来疯直播前不久开源的iOS推流框架LFLiveKit 七牛的霹雳直播 PLCameraStreamingKit bilibili的视频直播的框架ijkplayer 二、ijkplayer 概念ijkplayer 是一款做视频直播的框架, 基于ffmpeg, 支持 Android 和 iOS。ijkplayer 是bilibili对开源框架FFmpeg(一个基于C的软解码视频播放开源框架)的封装。他使用起来更加方便和简单。 集成iOS中集成ijkplayer视频直播框架 基本用法 1234567891011121314151617181920212223242526272829303132 IJKFFOptions *option = [IJKFFOptions optionsByDefault];[option setPlayerOptionValue:@"1" forKey:@"an"];// 开启硬解码[option setPlayerOptionValue:@"1" forKey:@"videotoolbox"];IJKFFMoviePlayerController *moviePlayer = [[IJKFFMoviePlayerController alloc] initWithContentURLString:live.flv withOptions:option];moviePlayer.view.frame = self.playView.bounds;// 填充fillmoviePlayer.scalingMode = IJKMPMovieScalingModeAspectFill;// 设置自动播放moviePlayer.shouldAutoplay = YES;[self.playView addSubview:moviePlayer.view];[moviePlayer prepareToPlay];self.moviePlayer = moviePlayer;IJKFFOptions *options = [IJKFFOptions optionsByDefault];[options setPlayerOptionIntValue:1 forKey:@"videotoolbox"];// 帧速率(fps) （可以改，确认非标准桢率会导致音画不同步，所以只能设定为15或者29.97）[options setPlayerOptionIntValue:29.97 forKey:@"r"];// -vol——设置音量大小，256为标准音量。（要设置成两倍音量时则输入512，依此类推[options setPlayerOptionIntValue:512 forKey:@"vol"];IJKFFMoviePlayerController *moviePlayer = [[IJKFFMoviePlayerController alloc] initWithContentURLString:flv withOptions:options];moviePlayer.view.frame = self.contentView.bounds;// 填充fillmoviePlayer.scalingMode = IJKMPMovieScalingModeAspectFill;// 设置自动播放(必须设置为NO, 防止自动播放, 才能更好的控制直播的状态)moviePlayer.shouldAutoplay = NO;// 默认不显示moviePlayer.shouldShowHudView = NO; 基于ijkplayer的Demohttps://github.com/GrayJIAXU/520Linkeehttps://github.com/SunLiner/MiaowShowhttps://github.com/chenliming777/LMLiveStreaming]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[视频直播第一弹 — 基础概念]]></title>
      <url>%2F2016%2F11%2F18%2FiOS-zhibo1%2F</url>
      <content type="text"><![CDATA[主要内容包括iOS直播技术中使用的基础技术与协议。 一、流媒体协议介绍1. 伪流媒体123渐进式下载 : 边下边存, 文件会保存使用http协议,也能够实现视频播放, 也能快进快退等, 体验上跟流媒体很像. 优酷, 土豆.这些网址就在使用这项技术.特点:实现简单, 成本也低 2. 流媒体123456边下边播, 不会保存文件,特点:流过就没有了.常用的协议有两个,分别为HLS (HTTP Live Streaming) 和 RTMP (Real Time Messaging Protocol)HLS (HTTP Live Streaming)，Apple的动态码率自适应技术。主要用于Mac和iOS音视频服务。包括一个m3u(8)的索引文件(.M3u8)，多个TS媒体分片文件(.ts)和key加密串文件。支持推流和播放. iOS自带的播放器就可以直接播放基于HLS协议的视频.RTMP是Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。该协议基于TCP，是一个协议族，包括RTMP基本协议及RTMPT/RTMPS/RTMPE等多种变种。RTMP是一种设计用来进行实时数据通信的网络协议，主要用来在Flash/AIR平台和支持RTMP协议的流媒体/交互服务器之间进行音视频和数据通信.RTMP实时消息传送协议协议概述编辑RTMP(Real Time Messaging Protocol)实时消息传送协议是Adobe Systems公司为Flash播放器和服务器之间音频、视频和数据传输 开发的开放协议。它有多种变种：① RTMP工作在TCP之上，默认使用端口1935；② RTMPE在RTMP的基础上增加了加密功能；RTMPT封装在HTTP请求之上，可穿透防火墙；③ RTMPS类似RTMPT，增加了TLS/SSL的安全功能; 二、RTMP协议 概念RTMP是Real Time Messaging Protocol（实时消息传输协议）。该协议基于TCP，是一个协议族，包括RTMP基本协议及RTMPT/RTMPS/RTMPE等多种变种。RTMP是一种设计用来进行实时数据通信的网络协议，主要用来在Flash/AIR平台和支持RTMP协议的流媒体/交互服务器之间进行音视频和数据通信。支持该协议的软件包括Adobe Media Server/Ultrant Media Server/red5等。 RTMP、HLS比较 123直播应用中，RTMP和HLS基本上可以覆盖所有客户端观看。HLS主要是延时比较大，RTMP主要优势在于延时低。RTMP协议的默认端口是1935，采用TCP协议。 推流器RTMP推流器（Streamer）。首先将视频数据以RTMP的形式发送到流媒体服务器端（Server，比如FMS，Red5，Wowza等），然后客户端（一般为Flash Player）通过访问流媒体服务器就可以收看实时流了。 三、FFMpegFFmpeg是一个开源免费跨平台的视频和音频流方案，属于自由软件，采用LGPL或GPL许可证（依据你选择的组件）。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多codec都是从头开发的。 ffmpeg项目由以下几部分组成: 1234567ffmpeg 视频文件转换命令行工具,也支持经过实时电视卡抓取和编码成视频文件.ffserver 基于HTTP、RTSP用于实时广播的多媒体服务器.也支持时间平移ffplay 用 SDL和FFmpeg库开发的一个简单的媒体播放器libavcodec 一个包含了所有FFmpeg音视频编解码器的库.为了保证最优性能和高可复用性,大多数编解码器从头开发的.libavformat 一个包含了所有的普通音视格式的解析器和产生器的库 FFmpeg常用推流命令]]></content>
    </entry>

    
  
  
</search>
